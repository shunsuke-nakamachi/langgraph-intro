# Multi-Agent System（マルチエージェントシステム）

このレッスンでは、**複数のエージェントが協調して動作するマルチエージェントシステム**を学びます。

実務では、1つのタスクを複数の専門家に分担させ、それぞれの専門性を活かしながら協調して成果物を作成するという設計がよく使われます。例えば、「記事作成」というタスクを「リサーチャー」「ライター」「レビュアー」「エディター」に分担させることで、高品質な成果物を効率的に作成できます。

## 学ぶこと

1. **複数の専門エージェントの定義**: それぞれが特定のタスクに特化したエージェントを作る
2. **並列実行（Fan-out）**: 複数のエージェントを同時に実行して処理時間を短縮
3. **結果の集約（Fan-in）**: 複数のエージェントの結果を1つにまとめる
4. **順次実行**: 前のエージェントの結果を次のエージェントが使う流れ
5. **エージェント間の協調**: 情報の共有と結果の統合

## なぜ必要か

### 1. 専門性の活用

1つのエージェントに全てのタスクを持たせると：

- **品質の低下**: 「リサーチも、執筆も、レビューも」を1つのエージェントが行うと、それぞれの品質が下がる
- **処理時間の増加**: 順次処理になるため、全体の処理時間が長くなる
- **拡張性の欠如**: 新しい専門家を追加するのが困難

### 2. マルチエージェントシステムの利点

- **専門性の向上**: 各エージェントが1つのタスクに集中できるため、品質が向上
- **処理時間の短縮**: 並列実行により、全体の処理時間を短縮
- **拡張性**: 新しいエージェントを追加するだけで機能を拡張できる
- **柔軟性**: エージェントの組み合わせを変えることで、様々なワークフローに対応

### 3. 実務での応用例

- **記事作成システム**: リサーチャー → ライター → レビュアー → エディター
- **コードレビューシステム**: 静的解析エージェント → セキュリティチェックエージェント → コードレビュアー
- **データ分析システム**: データ収集エージェント → 分析エージェント → 可視化エージェント → レポート作成エージェント

## コードの解説

### 1. State の定義

```python
class State(TypedDict):
    messages: Annotated[List, add_messages]
    topic: str  # 記事のトピック
    research_results: Annotated[List[str], operator.add]  # リサーチ結果（複数エージェントから集約）
    draft: Optional[str]  # ライターが作成した下書き
    review_feedback: Optional[str]  # レビュアーからのフィードバック
    final_article: Optional[str]  # 最終的な記事
```

**ポイント**:
- **`research_results: Annotated[List[str], operator.add]`**: 複数のリサーチャーエージェントの結果を集約するために、`operator.add`を使用
- これにより、複数のエージェントが並列に実行されても、結果が上書きされずに追加される

### 2. 専門エージェントの定義

#### Researcher Agent 1（技術情報リサーチャー）

```python
def researcher_agent_1(state: State) -> dict:
    """リサーチエージェント1: 技術的な情報を収集"""
    messages = [
        SystemMessage(content="あなたは技術情報を専門にリサーチするエージェントです。..."),
        HumanMessage(content=f"「{topic}」について、技術的な観点から重要な情報を3つ挙げてください。")
    ]
    response = llm.invoke(messages)
    return {"research_results": [research_result]}
```

- **役割**: 技術的な詳細、仕様、実装方法などを調べる
- **特徴**: 技術的な正確性を重視

#### Researcher Agent 2（市場動向リサーチャー）

```python
def researcher_agent_2(state: State) -> dict:
    """リサーチエージェント2: 市場動向やトレンドを収集"""
    # 市場動向、業界の動向、市場規模、将来予測などを調べる
```

- **役割**: 市場動向やトレンドを調べる
- **特徴**: ビジネス視点を重視

#### Researcher Agent 3（ユーザー視点リサーチャー）

```python
def researcher_agent_3(state: State) -> dict:
    """リサーチエージェント3: ユーザー視点や事例を収集"""
    # 実際の使用例、ユーザーの声、成功事例などを調べる
```

- **役割**: ユーザー視点や実用例を調べる
- **特徴**: 実用性を重視

#### Writer Agent（ライター）

```python
def writer_agent(state: State) -> dict:
    """ライターエージェント: リサーチ結果を元に記事を執筆"""
    research_summary = "\n\n".join(research_results)
    # リサーチ結果を元に記事を執筆
```

- **役割**: 複数のリサーチ結果を統合して記事を執筆
- **特徴**: すべてのリサーチ結果を参照できる

#### Reviewer Agent（レビュアー）

```python
def reviewer_agent(state: State) -> dict:
    """レビュアーエージェント: 記事をレビューしてフィードバックを提供"""
    # 記事の品質、正確性、読みやすさを評価
```

- **役割**: 記事の品質を評価し、改善点を指摘
- **特徴**: 客観的な視点で評価

#### Editor Agent（エディター）

```python
def editor_agent(state: State) -> dict:
    """エディターエージェント: レビューフィードバックを元に記事を最終化"""
    # レビューフィードバックを踏まえて記事を最終化
```

- **役割**: レビューフィードバックを反映して記事を最終化
- **特徴**: 最終的な品質を保証

### 3. グラフの構造

```
START
  ├─→ researcher_1 ─┐
  ├─→ researcher_2 ─┼─→ writer → reviewer → editor → END
  └─→ researcher_3 ─┘
```

**実行の流れ**:

1. **並列実行（Fan-out）**: 
   - 3つのリサーチャーエージェントが同時に実行される
   - それぞれが異なる視点から情報を収集
   - `operator.add`により、結果がリストに追加される

2. **結果の集約（Fan-in）**:
   - すべてのリサーチが完了したら、ライターエージェントが実行される
   - LangGraphは自動的に、すべての親ノードの完了を待ってからライターを実行

3. **順次実行**:
   - ライター → レビュアー → エディターの順で実行
   - 前のエージェントの結果を次のエージェントが使用

### 4. Fan-out / Fan-in パターン

**Fan-out（拡散）**:
```python
builder.add_edge(START, "researcher_1")
builder.add_edge(START, "researcher_2")
builder.add_edge(START, "researcher_3")
```

- 1つのノード（START）から複数のノード（3つのリサーチャー）へ同時に遷移
- これにより、3つのリサーチが並列に実行される

**Fan-in（集約）**:
```python
builder.add_edge("researcher_1", "writer")
builder.add_edge("researcher_2", "writer")
builder.add_edge("researcher_3", "writer")
```

- 複数のノード（3つのリサーチャー）から1つのノード（ライター）へ遷移
- LangGraphは自動的に、すべての親ノードの完了を待ってからライターを実行

**`operator.add`の重要性**:
```python
research_results: Annotated[List[str], operator.add]
```

- 通常の`List`だと、複数のエージェントが同時に`research_results`を更新しようとすると、上書き競合が発生する可能性がある
- `operator.add`を使うことで、各エージェントの結果が**追加**されることが保証される

## 実行方法

```bash
python multi_agent_bot.py
```

このスクリプトは、以下の3つのトピックについて記事を作成します：

1. **LangGraphの特徴と使い方**
2. **マルチエージェントシステムの設計**
3. **AIエージェントの実装パターン**

実行ログを見ることで、複数のエージェントが協調して動作する様子が確認できます。

## 実務での応用例

### 1. 記事作成システム

```
リサーチャー（技術） ─┐
リサーチャー（市場） ─┼─→ ライター → レビュアー → エディター
リサーチャー（ユーザー）┘
```

### 2. コードレビューシステム

```
静的解析エージェント ─┐
セキュリティチェック ─┼─→ コードレビュアー → 修正提案エージェント
パフォーマンス分析 ─┘
```

### 3. データ分析システム

```
データ収集エージェント ─┐
データクリーニング ─┼─→ 分析エージェント → 可視化エージェント → レポート作成
データ検証エージェント ─┘
```

### 4. カスタマーサポートシステム

```
FAQ検索エージェント ─┐
技術ドキュメント検索 ─┼─→ 回答生成エージェント → 品質チェックエージェント
過去の事例検索 ─┘
```

## 拡張アイデア

### 1. エージェント間の通信

現在の実装では、Stateを通じて情報を共有していますが、エージェント間で直接メッセージを送受信する仕組みも考えられます。

### 2. 動的なエージェント選択

Supervisor Patternと組み合わせて、タスクの内容に応じて必要なエージェントを動的に選択することも可能です。

### 3. エージェントの品質評価

各エージェントの出力を評価し、品質が低い場合は別のエージェントに再実行させる仕組みも考えられます。

### 4. エージェントの学習

各エージェントの実行結果を記録し、過去の経験を活かして品質を向上させることも可能です。

## ベストプラクティス

### 1. エージェントの責任分離

- 各エージェントは1つの明確な責任を持つ
- エージェント間の依存関係を最小限に

### 2. 並列実行の活用

- 独立したタスクは並列実行する
- `operator.add`を使って結果を安全に集約

### 3. エラーハンドリング

- 各エージェントでエラーハンドリングを実装
- 1つのエージェントの失敗が全体に影響しないように

### 4. 状態管理

- Stateでエージェント間の情報共有を管理
- 必要な情報のみをStateに保持

## まとめ

Multi-Agent Systemは、**「適材適所」と「協調」**を実現するための設計パターンです。

- **専門性の向上**: 各エージェントが1つのタスクに集中できる
- **処理時間の短縮**: 並列実行により、全体の処理時間を短縮
- **拡張性**: 新しいエージェントを追加するだけで機能を拡張できる
- **柔軟性**: エージェントの組み合わせを変えることで、様々なワークフローに対応

大規模なシステムを構築する際には、このパターンが非常に有効です。複数の専門家が協調して動作することで、単一のエージェントでは実現できない高品質な成果物を作成できます。

